---
title: WP-BugKu-Web
toc: true
date: 2021-05-08 11:43:54
tags: [CTF, WriteUp]
categories: [100 Cyber security, 120 CTF, 121 Web ]
---

#### Web 18
提示：题目刷新几次后有提示，需要计算数值并post value。

*  考点：爬虫复习、利用eval()直接计算string内的数字公式、利用同一个Session进行get和post请求，防止网页动态刷新计算值失效、post请求中data注意格式为{‘somevtext’：’somevalue’}、python和PHP的计算方式不太一样，可能存在计算偏差导致得不到flag，需要重复发送几次。
    ```
import requests
from bs4 import BeautifulSoup

url = 'http://114.67.246.176:14925/'
s = requests.session()
r = s.get(url)
r.encoding = 'utf-8'
soup=BeautifulSoup(r.text,'lxml')
data=soup.select('div')
for item in data:
    #获取原文为804134448*284526014-53361872*1933492032+466213037-393751154*4253881+1224286171-1203351395*1548147628+1689398514=?;
    result=item.get_text()

result1=result[0:len(result)-3] #去掉后三位‘=?;’
result2 = eval(result1) #计算数值
result3={'value':result2} #添加post请求数据格式

mssg=s.post(url, data=result3) #利用同一个session，防止网页刷新。

print(mssg.text)
    ```

#### Web 19
提示： OK ,now you have to post the margin what you find

* 解题思路：刷新几次之后没有发现变化，f12看network请求，在response包header内看到base64加密的flag，解码后为‘跑的还不错，给你flag吧: MjE0Nzg1’，一开始并没有意识到后面是base64的密文，直到一次运行爬虫发现密文有=号结尾。根据其他人的解读，说margin是数字所以提示了有两次base64解密，完全没有意识到这一层，我只猜到了post数据时数据格式为{‘margin’:xxx}，不得不说这提示的语法不太行，应该删掉what，这个着实困扰了。
    这个解开之后就简单很多了，另一个难点是在py3里string无法直接用base64解密，需要先转换成ascii。以及解密之后的返回值为bytes，需要转换成utf-8格式再进行后续删减处理，不然有`b’‘`等噪音。
    ```
    import base64
    import requests

    url='http://114.67.246.176:19877/'
    s=requests.session()

    r=s.get(url).headers.get('flag')
    r1=base64.b64decode(r.encode('ascii'))
    r2=r1.decode("utf-8")
    r3=r2[len(r2)-8:len(r2)]
    r4=base64.b64decode(r3.encode('ascii')).decode("utf-8")

    print(s.post(url, data={'margin':r4}).text)
    ```

#### Web 23
题目：
```
<?php
highlight_file('2.php');
$key='flag{********************************}';
$IM= preg_match("/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i", trim($_GET["id"]), $match);
if( $IM ){
 die('key is: '.$key);
}
?>
```

* 解题思路：基本上难点都在这句正则上了，外加一个trim()去掉输入值前后的空白字符。解读一下php语句，就是当id的输入值符合正则时，退出（die）并返回key。2.php在此处仅为含有该php语句的文件（highlight_file），与输入值无关。跟着这道题试验了好几个找到的在线正则工具，发现还是regex101好用。
  `/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i`，`{4,7}`表示重复前面部分4～7次，`[:punct:]`为所有的特殊字符。
  payload：`keykeykkeykey:/k/keya[:punct:]`

#### Web 24
题目：
```
<?php
if(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){
    $v1 = $_GET['v1'];
    $v2 = $_GET['v2'];
    $v3 = $_GET['v3'];
    if($v1 != $v2 && md5($v1) == md5($v2)){
        if(!strcmp($v3, $flag)){
            echo $flag;
        }
    }
}
?>
```

* 解题思路：似曾相识的MD5相等题，此次应掏出MD5绕过笔记。strcmp(str1,str2),如果str1小于str2返回<0；如果str1大于str2返回>0；如果两者相等，返回0。因为是if(!xxx)返回flag，所以v3和flag相等。搜索strcmp绕过，可知当传入的类型非期望类型时，即传入值非string时，发生错误，返回0。如：数组,`?a[]=2`

#### Web 25
提示：SQL约束攻击

* 解题思路：点开链接，发现是一个后台登录站点，先放着不管，查一下提示给的SQL约束攻击。内容也算似曾相识，之前在bug bounty的hint里面见过，也就是利用用户名长度限制，在用户名最后加上多个空白字符以及末尾一个用于绕过用户名是否已注册的对比的任意字符，那么在存储时，数据库仅存储前X位字符，导致攻击者可以取代登录目标用户。ref：https://www.freebuf.com/articles/web/124537.html
  知道了就简单了，思路是先盲猜管理员用户名，然后通过SQL约束攻击注册新帐号，取代替换原管理员帐号的密码。

#### Web 26
提示：are you from google?

* 解题思路：这个提示已经很明显了，直接包头加转发（referer），表示自己是从google来的就行。突然在想x-forwarded-for为啥不行，查了一下XFF必须是IP地址。

#### Web 27
提示：
    1. please input a
    2. md5 collision

* 解题思路：MD5碰撞，题面只有一句please input a，盲猜是输入a和某个值碰撞，那么首先试试输入数组报错法，回显`false!!`，起码证明思路应该是对的，重新查了查MD5碰撞，猜测题目是强类型不能绕过。但不知道另一个对比值要怎么做真实碰撞呢？
  好家伙，看了看提示，发现是没给对比值源码。。。行8

#### Web 28
提示：请从本地访问。

* 解题思路：好的看到本地访问又稳了，直接开链接搞XFF。题目不但似曾相识还莫名的变简单了。。。
  我一般是上burp，不过在评论里看到一个`curl -H "X-Forwarded-For: 127.0.0.1" http://114.67.246.176:18832/`，码住。

#### Web 29
题目：
```
<?php
highlight_file('flag.php');
$_GET['id'] = urldecode($_GET['id']);
$flag = 'flag{xxxxxxxxxxxxxxxxxx}';
if (isset($_GET['uname']) and isset($_POST['passwd'])) {
   if ($_GET['uname'] == $_POST['passwd'])

       print 'passwd can not be uname.';

   else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&($_GET['id']=='margin'))

       die('Flag: '.$flag);
   else
       print 'sorry!';

}
?>
```

* 解题思路：`urldecode，解码给出的已编码字符串中的任何%##，加号（'+'）被解码成一个空格字符。`看题目是个sha1绕过，查了一下和MD5绕过差不多，弱类型可以用数组，强类型可以用碰撞结果相同的值（`sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m')`）。

#### Web 30
题目：
```
<?php
extract($_GET);
if (!empty($ac))
{
$f = trim(file_get_contents($fn));
if ($ac === $f)
{
echo "<p>This is flag:" ." $flag</p>";
}
else
{
echo "<p>sorry!</p>";
}
}
?>
```

* 解题思路：`extract — 从数组中将变量导入到当前的符号表。`不是很熟练，看了评论，是导入站点的文件并且和get输入变量对比。另一个思路file_get_contents绕过。所以有两种方式，一种是利用站点文件flag.txt，输入`?fn=flag.txt&ac=bugku`，另一种是`?ac=bug&fn=php://input`，post数据`bug`。

#### Web 31
提示：好像需要管理员

* 解题思路：一打开是个404,最下面是`Generated by kangle/3.5.5.` ，结合提示需要管理员，那就先从这个入手找找漏洞。搜了一下，控制面板管理员后台3312/admin，但是分发的虚拟机也不太能这么找后台。上sourceleakhacker扫一下，robots.txt爆出一个路径`Disallow: /resusl.php`，访问，提示`Warning:你不是管理员你的IP已经被记录到日志了`以及`if ($_GET[x]==$password) 此处省略1w字`，也就是XFF127.0.0.1并发送password，结合kangle的弱口令admin/admin，得到flag。这里发送包有XFF但password不对时显示的IP地址还是我本地址而不是127.0.0.1,差点又以为思路错了。

#### Web 32
题目：文件上传;My name is margin,give me a image file not a php

* 解题思路：文件上传漏洞，掏出上传fuzz试试看。
  fuzz没过，看评论说是把multipart/form-data;修改成Content-Type: mulTipart/form-data; ，然后修改php文件为php4，竟然还有这种操作，学到了。

#### Web 33
提示：
```
Flag:{xxx}
fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=
 // 本人按：解密为}l.&W'EG*B(W[(+G'U-0，但这个并不是看起来的20位长度，而是算上不可见字符的38位长。所以碰到这种还是应该直接写代码而不是粘贴密文，以防万一。
```
题目：
```
<?php
function encrypt($data,$key)
{
    $key = md5('ISCC');
    $x = 0;
    $len = strlen($data);
    $klen = strlen($key);
    for ($i=0; $i < $len; $i++) {
        if ($x == $klen)
        {
            $x = 0;
        }
        $char .= $key[$x];
        $x+=1;
    }
    for ($i=0; $i < $len; $i++) {
        $str .= chr((ord($data[$i]) + ord($char[$i])) % 128);
    }
    return base64_encode($str);
}
?>
```

* 解题思路：在线解base64的时候还没注意到，复制下来才发现还有特殊字符。`.=连接赋值运算符，将右边参数附加到左边的参数之后。`完整的看了一遍代码，发现应该是如何计算出提示中base64字符串的算法。懒得配环境，对PHP一直是只会读代码不会写应用的状态，干脆在网上找了找PHP在线运行网站`www.anycodes.cn`。试着运行了一下原算法，用不同的数字和字母输入data内容，观察运行。
然后根据提示中的base64推断可得data长度。
逆推写了一下获取data的源码：
```
<?php
$str='fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=';
$str_decode = base64_decode($str);
$len1=strlen($str_decode);

$key = md5('ISCC');  # 729623334f0aa2784a1599fd374c120d
$klen = strlen($key);
$char = '';
$data = '';
for ($i=0; $i < $len1; $i++) {
        if ($x == $klen)
        {
            $x = 0;
        }
        $char .= $key[$x]; # 729623334f0aa2784a1599fd374c120d729623
        $x+=1;
    }
# print($len1); -> 38
# print($char); -> 729623334f0aa2784a1599fd374c120d729623
for ($i=0; $i < $len1; $i++) {
        $data .= chr((ord($str_decode[$i])+128)-ord($char[$i]));
    }
print($data);    
?>
```
得到结果：lag{asdqwdfasfdawfefqwdqwdadwqadawd}，提示里写了Flag:{xxx}，所以把结果改成Flag:{asdqwdfasfdawfefqwdqwdadwqadawd}，结果正确。
* 总结： 难点主要在一开始完整的阅读代码理解意思，并且顺利的逆推`$str .= chr((ord($data[$i]) + ord($char[$i])) % 128);`这句代码。关于这句代码我自己写了写逆推笔记，记录整理如下：
```
ord($di)+ord($ci) = A #简化原代码，$di=$data[$i],$ci=$char[$i],$str1=$str[$i].
$str1 = chr((ord($di)+ord($ci)) % 128) #chr和ord为互补，所以从右边拿到左边就变成ord。
ord($str1)=(ord($di)+ord($ci)) % 128 #在这里简化一下得到下面。
ord($str1)=(A) % 128
ord($str1)+128=(A) #这里有一点直觉的成分，因为ord得出的值范围在0～255之间，而A为两个ord相加，所以数值范围应该在0～510,也就是A mod 128的结果在0～127之间。无法确定到底A净除了几个128的情况下，我选择先加一个128,看一下到底能不能运行。（后续发现获得$di还是要经过一个chr，所以A到底多了几个128好像没啥影响）
ord($di) = A-ord($ci) #从最后产出的base64密文解密可得data的长度，而char的内容只和md5('ISCC')和data长度有关，所以可以知道char的内容。
$di = chr(A-ord($ci)) #这里可以把原本简化的A用原内容代替回来了。
$di = chr((ord($str1)+128)-ord($ci)) #思路就是这样，然后根据这个写代码。
```
